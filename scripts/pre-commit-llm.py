#!/usr/bin/env python3
"""
Pre-commit hook for .llm/ folder enforcement.

Checks:
1. No .md file under .llm/ exceeds 300 lines.
2. Auto-generates .llm/skills/index.md from skill file headings and descriptions.
3. Stages the auto-generated index file with git add.
4. Validates that all mkdocs.yml nav references point to existing files in docs/.
"""

import subprocess
import sys
from pathlib import Path

MAX_LINES = 300
REPO_ROOT = Path(__file__).resolve().parent.parent
LLM_DIR = REPO_ROOT / ".llm"
SKILLS_DIR = LLM_DIR / "skills"
INDEX_FILE = SKILLS_DIR / "index.md"


def find_md_files(directory: Path) -> list[Path]:
    """Recursively find all .md files under a directory."""
    return sorted(directory.rglob("*.md"))


def check_line_counts(md_files: list[Path]) -> list[str]:
    """Return a list of error messages for files exceeding MAX_LINES."""
    errors = []
    for path in md_files:
        try:
            lines = path.read_text(encoding="utf-8").splitlines()
            count = len(lines)
            if count > MAX_LINES:
                rel = path.relative_to(REPO_ROOT)
                errors.append(
                    f"  {rel}: {count} lines (limit is {MAX_LINES})"
                )
        except OSError as e:
            errors.append(f"  Could not read {path}: {e}")
    return errors


def extract_title(text: str) -> str:
    """Extract the first H1 heading from markdown text.

    Headings inside fenced code blocks (``` or ~~~) are ignored.
    """
    fence_char = None
    for line in text.splitlines():
        stripped = line.strip()
        if stripped.startswith("```") or stripped.startswith("~~~"):
            char = stripped[0]
            if fence_char is not None:
                if char == fence_char:
                    fence_char = None
                continue
            fence_char = char
            continue
        if fence_char is not None:
            continue
        if stripped.startswith("# "):
            return stripped[2:].strip()
    return "(Untitled)"


def extract_first_paragraph(text: str) -> str:
    """Extract the first non-heading, non-blank paragraph of text.

    Fenced code blocks (``` ... ``` and ~~~ ... ~~~) are properly skipped
    so that lines inside a code fence are never treated as paragraph content.
    Backtick fences and tilde fences are tracked independently per CommonMark.
    """
    lines = text.splitlines()
    in_paragraph = False
    fence_char = None
    paragraph_lines = []

    for line in lines:
        stripped = line.strip()
        # Toggle code-fence state on opening/closing markers
        if stripped.startswith("```") or stripped.startswith("~~~"):
            char = stripped[0]
            if fence_char is not None:
                if char == fence_char:
                    fence_char = None
                continue
            fence_char = char
            if in_paragraph:
                break
            continue
        # While inside a code fence, skip all lines
        if fence_char is not None:
            continue
        # Skip headings
        if stripped.startswith("#"):
            if in_paragraph:
                break
            continue
        # Blank line ends a paragraph
        if not stripped:
            if in_paragraph:
                break
            continue
        in_paragraph = True
        paragraph_lines.append(stripped)

    return " ".join(paragraph_lines).strip()


def generate_index(skill_files: list[Path]) -> str:
    """Generate the content of skills/index.md."""
    lines = [
        "# Skills Index",
        "",
        "> **AUTO-GENERATED** — Do not edit this file manually.",
        "> It is regenerated by `scripts/pre-commit-llm.py` on every commit.",
        "",
        "This index lists all skill reference guides available in `.llm/skills/`.",
        "Each skill is a focused, practical guide for a specific topic in this codebase.",
        "",
        "## Available Skills",
        "",
    ]

    for path in skill_files:
        rel = path.relative_to(SKILLS_DIR)
        try:
            text = path.read_text(encoding="utf-8")
        except OSError:
            continue

        title = extract_title(text)
        description = extract_first_paragraph(text)

        # Truncate long descriptions
        if len(description) > 120:
            description = description[:117] + "..."

        lines.append(f"### [{title}]({rel})")
        lines.append("")
        if description:
            lines.append(description)
            lines.append("")

    lines.append("---")
    lines.append("")
    lines.append(
        "*Generated by `scripts/pre-commit-llm.py`. "
        "Run `bash scripts/install-hooks.sh` to install the pre-commit hook.*"
    )
    lines.append("")

    return "\n".join(lines)


def git_add(path: Path) -> None:
    """Stage a file with git add."""
    rel = str(path.relative_to(REPO_ROOT))
    result = subprocess.run(
        ["git", "add", rel],
        cwd=str(REPO_ROOT),
        capture_output=True,
        text=True,
    )
    if result.returncode != 0:
        print(f"Warning: could not stage {rel}: {result.stderr.strip()}", file=sys.stderr)


def validate_mkdocs_nav() -> list[str]:
    """Validate that all files referenced in mkdocs.yml nav exist in docs/.

    Returns a list of error messages for missing files.
    """
    mkdocs_yml = REPO_ROOT / "mkdocs.yml"
    docs_dir = REPO_ROOT / "docs"
    errors = []

    if not mkdocs_yml.exists():
        return errors
    if not docs_dir.is_dir():
        return errors

    try:
        content = mkdocs_yml.read_text(encoding="utf-8")
    except OSError as e:
        errors.append(f"  Could not read {mkdocs_yml}: {e}")
        return errors
    in_nav = False

    for line_num, line in enumerate(content.splitlines(), start=1):
        trimmed = line.strip()

        # Detect the start of the nav section
        if trimmed == "nav:":
            in_nav = True
            continue

        # Detect exit from nav section (top-level key)
        if in_nav and line and not line.startswith(" ") and not line.startswith("#"):
            break

        if not in_nav:
            continue

        # Nav entries look like: `  - Label: filename.md`
        # or bare entries: `  - filename.md`
        if trimmed.startswith("- "):
            rest = trimmed[2:]
            # Split on the LAST `: ` to handle labels with colons
            colon_pos = rest.rfind(": ")
            if colon_pos != -1:
                file_ref = rest[colon_pos + 2:].strip()
            elif rest.strip().endswith(".md"):
                # Bare entry without a label (e.g., `- filename.md`)
                file_ref = rest.strip()
            else:
                file_ref = None

            if file_ref and file_ref.endswith(".md"):
                full_path = docs_dir / file_ref
                try:
                    exists = full_path.is_file()
                except OSError as e:
                    errors.append(f"  Could not check {full_path}: {e}")
                    continue
                if not exists:
                    errors.append(
                        f"  mkdocs.yml nav (line {line_num}) references "
                        f"'{file_ref}' but docs/{file_ref} does not exist."
                    )

    return errors


def main() -> int:
    if not LLM_DIR.exists():
        print("No .llm/ directory found — skipping LLM hook.", file=sys.stderr)
        return 0

    # 1. Collect all .md files under .llm/
    all_md = find_md_files(LLM_DIR)

    # Separate skill files (excluding index.md itself) from other .llm/ files
    skill_files = sorted(
        f for f in SKILLS_DIR.glob("*.md")
        if f.name != "index.md"
    ) if SKILLS_DIR.exists() else []

    # 2. Generate the index BEFORE line-count checks
    #    so that the index can be checked too
    if skill_files:
        index_content = generate_index(skill_files)
        INDEX_FILE.write_text(index_content, encoding="utf-8")
        git_add(INDEX_FILE)
        print(f"Generated .llm/skills/index.md ({len(index_content.splitlines())} lines)")

    # Refresh the list after generating index
    all_md = find_md_files(LLM_DIR)

    # 3. Check line counts for all .md files under .llm/
    all_errors = []
    line_count_errors = check_line_counts(all_md)
    all_errors.extend(line_count_errors)

    # 4. Run devcontainer documentation validation (non-blocking)
    validate_script = REPO_ROOT / "scripts" / "validate-devcontainer-docs.sh"
    if validate_script.exists():
        result = subprocess.run(
            ["bash", str(validate_script)],
            cwd=str(REPO_ROOT),
            capture_output=True,
            text=True,
        )
        if result.returncode != 0:
            print(
                "\nWarning: devcontainer documentation validation failed:",
                file=sys.stderr,
            )
            if result.stdout.strip():
                for line in result.stdout.strip().splitlines():
                    print(f"  {line}", file=sys.stderr)
            if result.stderr.strip():
                for line in result.stderr.strip().splitlines():
                    print(f"  {line}", file=sys.stderr)
        else:
            if result.stdout.strip():
                print(result.stdout.strip())

    # 5. Validate mkdocs.yml nav references (blocking)
    nav_errors = validate_mkdocs_nav()
    all_errors.extend(nav_errors)

    # 6. Report all collected errors together
    if all_errors:
        if line_count_errors:
            print(
                f"\nPre-commit hook FAILED: The following .llm/ files exceed {MAX_LINES} lines:",
                file=sys.stderr,
            )
            for error in line_count_errors:
                print(error, file=sys.stderr)
            print(
                "\nPlease split these files or reduce their content before committing.",
                file=sys.stderr,
            )
        if nav_errors:
            print(
                "\nPre-commit hook FAILED: mkdocs.yml nav references missing files:",
                file=sys.stderr,
            )
            for error in nav_errors:
                print(error, file=sys.stderr)
            print(
                "\nEvery file in mkdocs.yml nav must exist in docs/. "
                "Either create the file or remove the nav entry.",
                file=sys.stderr,
            )
        return 1

    # Report clean status
    counts = []
    for path in all_md:
        n = len(path.read_text(encoding="utf-8").splitlines())
        rel = path.relative_to(REPO_ROOT)
        counts.append(f"  {rel}: {n} lines")

    print("All .llm/ files are within the 300-line limit:")
    for c in counts:
        print(c)

    return 0


if __name__ == "__main__":
    sys.exit(main())
